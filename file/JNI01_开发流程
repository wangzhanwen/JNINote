JNI开发流程主要分为以下6步：

1、编写声明了native方法的Java类

2、将Java源代码编译成class字节码文件

3、用javah -jni命令生成.h头文件（javah是jdk自带的一个命令，-jni参数表示将class中用native声明的函数生成jni规则的函数）

4、用本地代码实现.h头文件中的函数

5、将本地代码编译成动态库（windows：*.dll，Linux/unix：*.so，mac os x：*.jnilib）

6、拷贝动态库至 java.library.path 本地库搜索目录下，并运行Java程序


第一步、新建一个HelloWorld.java源文件
      public class HelloWorld {

      public static native String sayHello(String name);  // 1.声明这是一个native函数，由本地代码实现

              public static void main(String[] args) {
                 String text = sayHello("yangxin");  // 3.调用本地函数
                 System.out.println(text);
              }

              static {
                 System.loadLibrary("HelloWorld");   // 2.加载实现了native函数的动态库，只需要写动态库的名字
              }

      }


第二步、用javac命令将.java源文件编译成.class字节码文件
      javac src/com/study/jnilearn/HelloWorld.java -d ./bin
      -d 表示将编译后的class文件放到指定的目录下，这里把它放到和src同级的bin目录下

第三步、用javah -jni命令，根据class字节码文件生成.h头文件（-jni参数是可选的）
      javah -jni -classpath ./bin -d ./jni com.study.jnilearn.HelloWorld
      默认生成的.h头文件名为：com_study_jnilearn_HelloWorld.h（包名+类名.h），也可以通过-o参数指定生成头文件名称：
      javah -jni -classpath ./bin -o HelloWorld.h com.study.jnilearn.HelloWorld

      参数说明：

            -classpath ：类搜索路径，这里表示从当前的bin目录下查找

            -d ：将生成的头文件放到当前的jni目录下

            -o ： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）

            注意：-d和-o只能使用其中一个参数。


第四步、用本地代码实现.h头文件中的函数

      com_study_jnilearn_HelloWorld.h：

      /* DO NOT EDIT THIS FILE - it is machine generated */
      #include <jni.h>
      /* Header for class com_study_jnilearn_HelloWorld */

      #ifndef _Included_com_study_jnilearn_HelloWorld
      #define _Included_com_study_jnilearn_HelloWorld
      #ifdef __cplusplus
      extern "C" {
      #endif
      /*
       * Class:     com_study_jnilearn_HelloWorld
       * Method:    sayHello
       * Signature: (Ljava/lang/String;)Ljava/lang/String;
       */
      JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello
        (JNIEnv *, jclass, jstring);

      #ifdef __cplusplus
      }
      #endif
      #endif


      HelloWorld.c：
        #include "com_study_jnilearn_HelloWorld.h"
        #ifdef __cplusplus
        extern "C"
        {
        #endif

        /*
         * Class:     com_study_jnilearn_HelloWorld
         * Method:    sayHello
         * Signature: (Ljava/lang/String;)Ljava/lang/String;
         */
        JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello(
                JNIEnv *env, jclass cls, jstring j_str)
        {
            const char *c_str = NULL;
            char buff[128] = { 0 };
            c_str = (*env)->GetStringUTFChars(env, j_str, NULL);
            if (c_str == NULL)
            {
                printf("out of memory.\n");
                return NULL;
            }
            printf("Java Str:%s\n", c_str);
            sprintf(buff, "hello %s", c_str);
                (*env)->ReleaseStringUTFChars(env, j_str, c_str);
            return (*env)->NewStringUTF(env, buff);
        }
        #ifdef __cplusplus
        }
        #endif


第五步、将C/C++代码编译成本地动态库文件

      动态库文件名命名规则：lib+动态库文件名+后缀（操作系统不一样，后缀名也不一样）如：

      Mac OS X : libHelloWorld.jnilib

      Windows ：HelloWorld.dll（不需要lib前缀）

      linux/Unix：libHelloWorld.so

  （1）  Mac OS X :
         gcc
         -dynamiclib
         -o /Users/yangxin/Library/Java/Extensions/libHelloWorld.jnilib
         jni/HelloWorld.c
         -framework JavaVM
         -I/$JAVA_HOME/include
         -I/$JAVA_HOME/include/darwin

         例子：
         gcc
         -dynamiclib
         -o libJniTest.jnilib
         main.c
         -framework JavaVM
         -I/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/include
         -I/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/include/darwin

         参数选项说明：

            -dynamiclib：表示编译成动态链接库

            -o：指定动态链接库编译后生成的路径及文件名

            -framework JavaVM -I：编译JNI需要用到JVM的头文件(jni.h)，第一个目录是平台无关的，第二个目录是与操作系统平台相关的头文件

 （2）Linux/Unix
     gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so
     例子：
      gcc
      -I/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/include
      -I/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/include/darwin
      -fPIC
      -shared
      main.c
      -o libJniTest.so

     参数说明：

         -I：          包含编译JNI必要的头文件

         -fPIC：    编译成与位置无关的独立代码

         -shared：编译成动态库

         -o：         指定编译后动态库生成的路径和文件名

（3）Windows：
     cl -I"%JAVA_HOME%\include" -I"%JAVA_HOME%\include\win32" -LD HelloWorld.c -FeHelloWorld.dll
     参数选项说明：

          -I ：   和mac os x一样，包含编译JNI必要的头文件

          -LD：标识将指定的文件编译成动态链接库

          -Fe：指定编译后生成的动态链接库的路径及文件名


第六步、运行Java程序
     加载动态库的两种方式：
     System.loadLibrary("HelloWorld");
     System.load("/Users/yangxin/Desktop/libHelloWorld.jnilib");
     方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀

     方式2：指定动态库的绝对路径名，需要加上前缀和后缀
     如果使用方式1，java会去java.library.path系统属性指定的目录下查找动态库文件，
     如果没有找到会抛出java.lang.UnsatisfiedLinkError异常

     String libraryDirs = System.getProperty("java.library.path");
     有两种方式可以让java从java.library.path找到动态链接库文件，聪明的你应该已经想到了。

     方式1：将动态链接库拷贝到java.library.path目录下

     方式2：给jvm添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性java.library.path的值

     java -Djava.library.path=/Users/yangxin/Desktop

    xcode c/c++  添加头文件搜索路径 ：点击工程-> BuildSetting -> 搜索框：search ->Header Search Paths:
     /Users/yidong9/Library/Android/ndk/android-ndk-r11b/platforms/android-24/arch-arm/usr/include
